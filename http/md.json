{
  "text": "# 写在前面\n\n新增了一行内容。\n整个项目都托管在了 Github 上：<https://github.com/ikesnowy/Algorithms-4th-Edition-in-Csharp>\n查找更方便的版本见：<https://alg4.ikesnowy.com/>\n这一节内容可能会用到的库文件有 SymbolTable，同样在 Github 上可以找到。\n善用 Ctrl + F 查找题目。\n\n### 习题&题解\n\n\n#### 3.1.1\n\n##### 解答\n\n官方解答：<https://algs4.cs.princeton.edu/31elementary/GPA.java.html>\nST.java：<https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/ST.java.html>\n\n建立一个符号表，然后把键值放进去，读取计算即可。\n和上一章节用过的方法类似，先定义了一个接口 `IST<Key, Value>` ，包含书中提到的基本 API。\n然后定义类 `ST` ，用标准库里面的 `Dictionary` 实现了 `IST` 。\n\n##### 代码\n\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace SymbolTable\n{\n    /// <summary> 利用库函数实现的标准符号表。 </summary>\n    public class ST<Key, Value> : IST<Key, Value>, IEnumerable<Key>\n    {\n        private Dictionary<Key, Value> st;\n\n        /// <summary> 新建一个符号表。 </summary>\n        public ST() => this.st = new Dictionary<Key, Value>();\n\n        /// <summary> 检查符号表中是否存在与键 <paramref name=\"key\"/> 对应的值。 </summary>\n        public virtual bool Contains(Key key) => this.st.ContainsKey(key);\n\n        /// <summary> 从符号表中删除键 <paramref name=\"key\"/> 及对应的值。 </summary>\n        public virtual void Delete(Key key) => this.st.Remove(key);\n\n        /// <summary> 获取键 <paramref name=\"key\"/> 对应的值，不存在时返回 null。 </summary>\n        public virtual Value Get(Key key) => this.st[key];\n\n        /// <summary> 获取枚举器。 </summary>\n        public IEnumerator<Key> GetEnumerator() => this.st.Keys.GetEnumerator();\n\n        /// <summary> 检查符号表是否为空。 </summary>\n        public virtual bool IsEmpty() => this.st.Count == 0;\n\n        /// <summary> 获得符号表中所有键的集合。 </summary>\n        public virtual IEnumerable<Key> Keys() => this.st.Keys;\n\n        /// <summary> 向符号表中插入新的键值对。 </summary>\n        public virtual void Put(Key key, Value value) => this.st.Add(key, value);\n\n        /// <summary> 获取符号表中键值对的数量。 </summary>\n        public virtual int Size() => this.st.Count;\n\n        /// <summary> 获取枚举器。 </summary>\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://github.com/ikesnowy/Algorithms-4th-Edition-in-Csharp/tree/master/3%20Searching/3.1/SymbolTable)\n\n\n#### 3.1.2\n\n##### 解答\n\n官方解答：<https://algs4.cs.princeton.edu/31elementary/ArrayST.java.html>\n\n建立两个数组，分别存放键和值，一一对应。\n添加时直接将新键值对放到数组最后即可。\n删除时将待删除的键值对和位于最后的键值对交换，然后将其置空即可。\n\n##### 代码\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nnamespace SymbolTable\n{\n    /// <summary>\n    /// 符号表（数组实现）。\n    /// </summary>\n    /// <typeparam name=\"Key\">键类型。</typeparam>\n    /// <typeparam name=\"Value\">值类型。</typeparam>\n    public class ArrayST<Key, Value> : IST<Key, Value> \n    {\n        private Key[] keys;             // 键数组\n        private Value[] values;         // 值数组\n        private int n = 0;              // 键值对数目\n\n        /// <summary>\n        /// 建立基于数组实现的符号表。\n        /// </summary>\n        public ArrayST() : this(8) { }\n\n        /// <summary>\n        /// 建立基于数组实现的符号表。\n        /// </summary>\n        /// <param name=\"initCapacity\">初始大小。</param>\n        public ArrayST(int initCapacity)\n        {\n            this.keys = new Key[initCapacity];\n            this.values = new Value[initCapacity];\n        }\n\n        /// <summary>\n        /// 检查键 <typeparamref name=\"Key\"/> 是否存在。\n        /// </summary>\n        /// <param name=\"key\">需要检查是否存在的键。</param>\n        /// <returns></returns>\n        public bool Contains(Key key) => Get(key).Equals(default(Key));\n\n        /// <summary>\n        /// 删除键 <paramref name=\"key\"/> 及对应的值。\n        /// </summary>\n        /// <param name=\"key\">需要删除的键。</param>\n        public void Delete(Key key)\n        {\n            for (int i = 0; i < this.n; i++)\n            {\n                if (key.Equals(this.keys[i]))\n                {\n                    this.keys[i] = this.keys[this.n - 1];\n                    this.values[i] = this.values[this.n - 1];\n                    this.keys[this.n - 1] = default(Key);\n                    this.values[this.n - 1] = default(Value);\n                    this.n--;\n                    if (this.n > 0 && this.n == this.keys.Length / 4)\n                        Resize(this.keys.Length / 2);\n                    return;\n                }\n            }\n        }\n\n        /// <summary>\n        /// 获取键对应的值，若键不存在则返回 null。\n        /// </summary>\n        /// <param name=\"key\">需要查找的键。</param>\n        /// <returns></returns>\n        public Value Get(Key key)\n        {\n            for (int i = 0; i < this.n; i++)\n                if (this.keys[i].Equals(key))\n                    return this.values[i];\n            return default(Value);\n        }\n\n        /// <summary>\n        /// 检查符号表是否为空。\n        /// </summary>\n        /// <returns></returns>\n        public bool IsEmpty() => this.n == 0;\n\n        /// <summary>\n        /// 获得包含全部键的集合。\n        /// </summary>\n        /// <returns></returns>\n        public IEnumerable<Key> Keys()\n        {\n            Key[] result = new Key[this.n];\n            Array.Copy(this.keys, result, this.n);\n            return result;\n        }\n\n        /// <summary>\n        /// 向符号表中插入新元素，若键存在将被替换。\n        /// </summary>\n        /// <param name=\"key\">键。</param>\n        /// <param name=\"value\">值。</param>\n        public void Put(Key key, Value value)\n        {\n            Delete(key);\n\n            if (this.n >= this.values.Length)\n                Resize(this.n * 2);\n\n            this.keys[this.n] = key;\n            this.values[this.n] = value;\n            this.n++;\n        }\n\n        /// <summary>\n        /// 返回符号表中键值对的数量。\n        /// </summary>\n        /// <returns>键值对数量。</returns>\n        public int Size() => this.n;\n\n        /// <summary>\n        /// 为符号表重新分配空间。\n        /// </summary>\n        /// <param name=\"capacity\">新分配的空间大小。</param>\n        private void Resize(int capacity)\n        {\n            Key[] tempKey = new Key[capacity];\n            Value[] tempValue = new Value[capacity];\n\n            for (int i = 0; i < this.n; i++)\n                tempKey[i] = this.keys[i];\n            for (int i = 0; i < this.n; i++)\n                tempValue[i] = this.values[i];\n\n            this.keys = tempKey;\n            this.values = tempValue;\n        }\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://github.com/ikesnowy/Algorithms-4th-Edition-in-Csharp/tree/master/3%20Searching/3.1/SymbolTable)\n\n\n#### 3.1.3\n\n##### 解答\n\n基于无序链表的官方实现：<https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html>\n\n有序符号表的 API 见书中表 3.1.4（中文版 P230，英文版 P366）。\n在官方实现的基础上修改 `Put` 方法，先找到合适位置再插入新的键值对，保证链表有序。\n为方便插入操作，可以使用双向链表作为基础进行实现。\n表中同时维护开头和末尾引用，加快获得最值的速度。\n\n##### 代码\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nnamespace SymbolTable\n{\n    /// <summary>\n    /// 基于有序链表的有序符号表实现。\n    /// </summary>\n    /// <typeparam name=\"Key\">符号表键类型。</typeparam>\n    /// <typeparam name=\"Value\">符号表值类型。</typeparam>\n    public class OrderedSequentialSearchST<Key, Value> : IST<Key, Value>, IOrderedST<Key, Value> \n        where Key : IComparable<Key>\n    {\n        /// <summary>\n        /// 符号表结点。\n        /// </summary>\n        private class Node\n        {\n            public Key Key { get; set; }        // 键。\n            public Value Value { get; set; }    // 值。\n            public Node Next { get; set; }      // 后继。\n            public Node Prev { get; set; }      // 前驱。\n        }\n\n        private Node first = null;      // 起始结点。\n        private Node tail = null;       // 末尾结点。\n        private int n = 0;              // 键值对数量。\n\n        /// <summary>\n        /// 构造基于有序链表的有序符号表。\n        /// </summary>\n        public OrderedSequentialSearchST() { }\n\n        /// <summary>\n        /// 大于等于 key 的最小值。\n        /// </summary>\n        /// <returns></returns>\n        public Key Ceiling(Key key)\n        {\n            Node pointer = this.tail;\n            while (pointer != null && Greater(key, pointer.Key))\n                pointer = pointer.Prev;\n            return pointer == null ? default(Key) : pointer.Key;\n        }\n\n        /// <summary>\n        /// 键 <paramref name=\"key\"/> 在表中是否存在对应的值。\n        /// </summary>\n        /// <param name=\"key\">键。</param>\n        /// <returns></returns>\n        public bool Contains(Key key) => Floor(key).Equals(key);\n\n        /// <summary>\n        /// 从表中删去键 <paramref name=\"key\"/> 对应的值。\n        /// </summary>\n        /// <param name=\"key\">键。</param>\n        public void Delete(Key key)\n        {\n            Node pointer = this.first;\n            while (pointer != null && !pointer.Key.Equals(key))\n                pointer = pointer.Next;\n            if (pointer == null)\n                return;\n            Delete(pointer);\n        }\n\n        /// <summary>\n        /// 从链表中删除结点 <paramref name=\"node\"/>。\n        /// </summary>\n        /// <param name=\"node\">待删除的结点。</param>\n        private void Delete(Node node)\n        {\n            Node prev = node.Prev;\n            Node next = node.Next;\n            if (prev == null)\n                this.first = next;\n            else\n                prev.Next = next;\n\n            if (next == null)\n                this.tail = prev;\n            this.n--;\n        }\n\n        /// <summary>\n        /// 删除最大的键。\n        /// </summary>\n        public void DeleteMax()\n        {\n            if (this.n == 0)\n                throw new Exception(\"ST Underflow\");\n            Delete(this.tail);\n        }\n\n        /// <summary>\n        /// 删除最小的键。\n        /// </summary>\n        public void DeleteMin()\n        {\n            if (this.n == 0)\n                throw new Exception(\"ST Underflow\");\n            Delete(this.first);\n        }\n\n        /// <summary>\n        /// 小于等于 Key 的最大值。\n        /// </summary>\n        /// <returns></returns>\n        public Key Floor(Key key)\n        {\n            Node pointer = this.first;\n            while (pointer != null && Less(key, pointer.Key))\n                pointer = pointer.Next;\n            return pointer == null ? default(Key) : pointer.Key;\n        }\n\n        /// <summary>\n        /// 获取键 <paramref name=\"key\"/> 对应的值，不存在则返回 null。\n        /// </summary>\n        /// <param name=\"key\">键。</param>\n        /// <returns></returns>\n        public Value Get(Key key)\n        {\n            Node pointer = this.first;\n            while (pointer != null && Greater(key, pointer.Key))\n                pointer = pointer.Next;\n\n            if (pointer == null)\n                return default(Value);\n            else if (pointer.Key.Equals(key))\n                return pointer.Value;\n            else\n                return default(Value);\n        }\n\n        /// <summary>\n        /// 符号表是否为空。\n        /// </summary>\n        /// <returns></returns>\n        public bool IsEmpty() => this.n == 0;\n\n        /// <summary>\n        /// 获得符号表中所有键的集合。\n        /// </summary>\n        /// <returns></returns>\n        public IEnumerable<Key> Keys() => this.n == 0 ? new List<Key>() : Keys(this.first.Key, this.tail.Key);\n\n        /// <summary>\n        /// 获得符号表中 [<paramref name=\"lo\"/>, <paramref name=\"hi\"/>] 之间的键。\n        /// </summary>\n        /// <param name=\"lo\">范围起点。</param>\n        /// <param name=\"hi\">范围终点。</param>\n        /// <returns></returns>\n        public IEnumerable<Key> Keys(Key lo, Key hi)\n        {\n            List<Key> list = new List<Key>();\n            Node pointer = this.first;\n            while (pointer != null && Less(pointer.Key, lo))\n                pointer = pointer.Next;\n            while (pointer != null && Less(pointer.Key, hi))\n            {\n                list.Add(pointer.Key);\n                pointer = pointer.Next;\n            }\n            if (pointer.Key.Equals(hi))\n                list.Add(pointer.Key);\n            return list;\n        }\n\n        /// <summary>\n        /// 最大的键。\n        /// </summary>\n        /// <returns></returns>\n        public Key Max() => this.tail == null ? default(Key) : this.tail.Key;\n\n        /// <summary>\n        /// 最小的键。\n        /// </summary>\n        /// <returns></returns>\n        public Key Min() => this.first == null ? default(Key) : this.first.Key;\n\n        /// <summary>\n        /// 向符号表插入键值对，重复值将被替换。\n        /// </summary>\n        /// <param name=\"key\">键。</param>\n        /// <param name=\"value\">值。</param>\n        public void Put(Key key, Value value)\n        {\n            Delete(key);\n\n            Node temp = new Node()\n            {\n                Key = key,\n                Value = value,\n                Prev = null,\n                Next = null\n            };\n\n            Node left = null, right = this.first;\n            while (right != null && Less(right.Key, temp.Key))\n            {\n                left = right;\n                right = right.Next;\n            }\n\n            Insert(left, right, temp);\n\n            if (left == null)\n                this.first = temp;\n            if (right == null)\n                this.tail = temp;\n            this.n++;\n        }\n\n        /// <summary>\n        /// 小于 Key 的键的数量。\n        /// </summary>\n        /// <returns></returns>\n        public int Rank(Key key)\n        {\n            int counter = 0;\n            Node pointer = this.first;\n            while (pointer != null && Less(pointer.Key, key))\n            {\n                pointer = pointer.Next;\n                counter++;\n            }\n            return counter;\n        }\n\n        /// <summary>\n        /// 获得排名为 k 的键（从 0 开始）。\n        /// </summary>\n        /// <param name=\"k\">排名</param>\n        /// <returns></returns>\n        public Key Select(int k)\n        {\n            if (k >= this.n)\n                throw new Exception(\"k must less than ST size!\");\n\n            Node pointer = this.first;\n            for (int i = 0; i < k; i++)\n                pointer = pointer.Next;\n            return pointer.Key;\n        }\n\n        /// <summary>\n        /// 获得符号表中键值对的数量。\n        /// </summary>\n        /// <returns></returns>\n        public int Size() => this.n;\n\n        /// <summary>\n        /// [<paramref name=\"lo\"/>, <paramref name=\"hi\"/>] 之间键的数量。\n        /// </summary>\n        /// <param name=\"lo\">范围起点。</param>\n        /// <param name=\"hi\">范围终点。</param>\n        /// <returns></returns>\n        public int Size(Key lo, Key hi)\n        {\n            int counter = 0;\n            Node pointer = this.first;\n            while (pointer != null && Less(pointer.Key, lo))\n                pointer = pointer.Next;\n            while (pointer != null && Less(pointer.Key, hi))\n            {\n                pointer = pointer.Next;\n                counter++;\n            }\n            return counter;\n        }\n\n        /// <summary>\n        /// 键 <paramref name=\"a\"/> 是否小于 <paramref name=\"b\"/>。\n        /// </summary>\n        /// <param name=\"a\">检查是否较小的键。</param>\n        /// <param name=\"b\">检查是否较大的键。</param>\n        /// <returns></returns>\n        private bool Less(Key a, Key b) => a.CompareTo(b) < 0;\n\n        /// <summary>\n        /// 键 <paramref name=\"a\"/> 是否大于 <paramref name=\"b\"/>。\n        /// </summary>\n        /// <param name=\"a\">检查是否较大的键。</param>\n        /// <param name=\"b\">检查是否较小的键。</param>\n        /// <returns></returns>\n        private bool Greater(Key a, Key b) => a.CompareTo(b) > 0;\n\n        /// <summary>\n        /// 将结点 <paramref name=\"k\"/> 插入到 <paramref name=\"left\"/> 和 <paramref name=\"right\"/> 之间。\n        /// </summary>\n        /// <param name=\"left\">作为前驱的结点。</param>\n        /// <param name=\"right\">作为后继的结点。</param>\n        /// <param name=\"insert\">待插入的结点。</param>\n        private void Insert(Node left, Node right, Node k)\n        {\n            k.Prev = left;\n            k.Next = right;\n            if (left != null)\n                left.Next = k;\n\n            if (right != null)\n                right.Prev = k;\n        }\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://github.com/ikesnowy/Algorithms-4th-Edition-in-Csharp/tree/master/3%20Searching/3.1/SymbolTable)\n\n#### 3.1.4\n\n##### 解答\n\n利用 `Time` 类型记录时间，用 `Event` 来记录事件内容。\n\n`Time` 类型包含时分秒三个 `int` 变量，同时实现 `IComparable` 接口。\n`Event` 类型只包含事件的名称，相当于对 `string` 做了一个封装。\n\n随后以 `Time` 为键类型，`Event` 为值类型，利用上一题编写的有序符号表进行操作。\n\n##### 代码\n\nTime 类\n\n```csharp\nusing System;\nusing System.Text;\n\nnamespace _3._1._4\n{\n    /// <summary>\n    /// 时间类。\n    /// </summary>\n    public class Time : IComparable<Time>\n    {\n        public int Hour { get; set; }\n        public int Minute { get; set; }\n        public int Second { get; set; }\n\n        public Time() : this(0, 0, 0) { }\n\n        public Time(int hour, int minute, int second)\n        {\n            this.Hour = hour;\n            this.Minute = minute;\n            this.Second = second;\n        }\n\n        public int CompareTo(Time other)\n        {\n            int result = this.Hour.CompareTo(other.Hour);\n            if (result == 0)\n                result = this.Minute.CompareTo(other.Minute);\n            if (result == 0)\n                result = this.Second.CompareTo(other.Second);\n            return result;\n        }\n\n        public override bool Equals(object obj)\n        {\n            if (this == obj)\n                return true;\n            return CompareTo((Time)obj) == 0;\n        }\n\n        public override int GetHashCode()\n        {\n            int result = 1;\n            result += this.Hour;\n            result *= 31;\n            result += this.Minute;\n            result *= 31;\n            result += this.Second;\n            return result;\n        }\n\n        public override string ToString()\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.Append(this.Hour < 10 ? \"0\" + this.Hour : this.Hour.ToString());\n            sb.Append(\":\");\n            sb.Append(this.Minute < 10 ? \"0\" + this.Minute : this.Minute.ToString());\n            sb.Append(\":\");\n            sb.Append(this.Second < 10 ? \"0\" + this.Second : this.Second.ToString());\n            return sb.ToString();\n        }\n    }\n}\n```\n\nEvent 类\n\n```csharp\nnamespace _3._1._4\n{\n    public class Event\n    {\n        public string EventMessage { get; set; }\n\n        public Event() : this(null) { }\n\n        public Event(string message)\n        {\n            this.EventMessage = message;\n        }\n\n        public override string ToString()\n        {\n            return this.EventMessage;\n        }\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.5\n\n##### 解答\n\n官方解答：<https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html>\n\n`size()` 方法只需要直接返回当前的 `n` 值即可。\n`delete()` 方法需要遍历链表，找到对应结点并删除。\n`keys()` 方法只需要根据当前的 `n` 新建一个数组，把链表中的键值存入即可。\n\n##### 代码\n\n```csharp\n/// <summary>\n/// 从表中删去键 <paramref name=\"key\"/> 及其对应的值。\n/// </summary>\n/// <param name=\"key\">要删除的键。</param>\npublic void Delete(Key key)\n{\n    if (key == null)\n        throw new ArgumentNullException(\"key can't be null\");\n    Node before = null, target = this.first;\n    while (target != null && !target.Key.Equals(key))\n    {\n        before = target;\n        target = target.Next;\n    }\n    if (target != null)\n        Delete(before, target);\n}\n\n/// <summary>\n/// 从链表中删除指定的结点。\n/// </summary>\n/// <param name=\"before\"><paramref name=\"target\"/> 的前驱。</param>\n/// <param name=\"target\">准备删除的结点。</param>\n/// <exception cref=\"ArgumentNullException\">当 <paramref name=\"target\"/> 为 <c>null</c> 时抛出此异常。</exception>\nprivate void Delete(Node before, Node target)\n{\n    if (target == null)\n        throw new ArgumentNullException(\"target can't be null\");\n\n    if (before == null)\n        this.first = target.Next;\n    else\n        before.Next = target.Next;\n    this.n--;\n}\n\n/// <summary>\n/// 获得所有的键。\n/// </summary>\n/// <returns>包含所有键的集合。</returns>\npublic IEnumerable<Key> Keys()\n{\n    Key[] keys = new Key[this.n];\n    Node pointer = this.first;\n    for (int i = 0; i < this.n; i++)\n    {\n        keys[i] = pointer.Key;\n        pointer = pointer.Next;\n    }\n    return keys;\n}\n\n/// <summary>\n/// 获取符号表中的键值对数量。\n/// </summary>\n/// <returns>当前符号表中的键值对数量。</returns>\npublic int Size() => this.n;\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.6\n\n##### 解答\n\nFrequencyCounter 的官方实现：<https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html>\n每个单词都会被放进符号表一次，\n因此 Put 的调用次数就等于单词总数 W +1（注意寻找最大值的时候有一次 Put 调用）\n对于重复的单词，输入时会先调用 Get 获得当前计数之后再 Put 回去。\n寻找最大值时，对于符号表中的每个键值都会调用两次 Get。\n重复的单词数量 = (W - D)。\n因此 Get 方法的调用次数 = (W - D) + 2D\n\n#### 3.1.7\n\n##### 解答\n\n在 `FrequencyCounter` 中添加一个 `CountDistinct` 方法，计算不重复的键数。\n\n```csharp\npublic static int CountDistinct<TKey>(TKey[] keys, IST<TKey, int> st)\n{\n    int distinct = 0;\n    for (int i = 0; i < keys.Length; i++)\n    {\n        if (!st.Contains(keys[i]))\n            st.Put(keys[i], distinct++);\n    }\n    return distinct;\n}\n```\n\n结果如下：\n![](https://img2018.cnblogs.com/blog/1177246/201902/1177246-20190217150920362-1787685147.png)\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.8\n\n##### 解答\n\nFrequencyCounter 的官方实现：<https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html>\n《双城记》：<https://introcs.cs.princeton.edu/java/data/tale.txt>\n\n官网给出的数据末尾有完整的版权说明，因此使用频率最高的单词变成了版权方的名字 Gutenberg-tm。\n去掉末尾的版权声明之后，获得的单词是：Monseigneur\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.9\n\n##### 解答\n\nFrequencyCounter 的官方实现：<https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html>\n《双城记》：<https://introcs.cs.princeton.edu/java/data/tale.txt>\n\n对 FrequencyCounter 做修改，在调用 `Put` 方法之前，将单词记录在字符串变量 `lastPut` 中。\n在读入单词结束之后输出 `lastPut` 和 `words` 变量。\n\n将末尾的版权信息删除后，得到的结果如下：\n![](https://img2018.cnblogs.com/blog/1177246/201902/1177246-20190219134653180-882330647.png)\n\n##### 代码\n\n```csharp\npublic static string MostFrequentlyWord(string filename, int minLength, IST<string, int> st)\n{\n    int distinct = 0, words = 0;\n    StreamReader sr = new StreamReader(File.OpenRead(filename));\n\n    string[] inputs = \n        sr\n        .ReadToEnd()\n        .Split(new char[] { ' ', '\\r', '\\n' }, \n        StringSplitOptions.RemoveEmptyEntries);\n\n    string lastPut = \"\";\n    foreach (string s in inputs)\n    {\n        if (s.Length < minLength)\n            continue;\n        words++;\n        if (st.Contains(s))\n        {\n            lastPut = s;\n            st.Put(s, st.Get(s) + 1);\n        }\n        else\n        {\n            lastPut = s;\n            st.Put(s, 1);\n            distinct++;\n        }\n    }\n\n    Console.WriteLine(\"Last Put: \" + lastPut + \"\\t words count: \" + words);\n\n    string max = \"\";\n    st.Put(max, 0);\n    foreach (string s in st.Keys())\n        if (st.Get(s) > st.Get(max))\n            max = s;\n\n    return max;\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n#### 3.1.10\n\n##### 解答\n\n如图所示：\n![](https://img2018.cnblogs.com/blog/1177246/201902/1177246-20190219211605599-684468041.png)\n\n插入新的键值对需要遍历整个链表，比较次数等于链表在插入前的键值对数目。\n修改已有的键值对则需要遍历链表直到找到该键值对，比较次数等于该键值对以及它之前所有键值对的数目。\n共比较 0 + 1 + 2 + 3 + 4 + 5 + 6 + 4 + 6 +  7 + 8 + 9 = 55 次。\n\n#### 3.1.11\n\n##### 解答\n\n键的轨迹如下图所示：\n![](https://img2018.cnblogs.com/blog/1177246/201902/1177246-20190220203716755-1743336870.png)\n\n键查找使用二分查找优化，插入新的键时不必与每个键都进行比较。\n共进行了 0 + 1 + 2 + 2 + 2 + 3 + 3 + 3 + 3 + 3 + 3 + 4 = 29 次比较。\n\n#### 3.1.12\n\n##### 解答\n\n建立类 `Item`：\n\n```csharp\npublic class Item<TKey, TValue> : IComparable<Item<TKey, TValue>>\n    where TKey : IComparable<TKey>\n{\n    public TKey Key { get; set; }\n    public TValue Value { get; set; }\n\n    public int CompareTo(Item<TKey, TValue> other)\n    {\n        return this.Key.CompareTo(other.Key);\n    }\n}\n```\n\n之后修改 `BinarySearchST`，将其中的 `TKey[] keys` 和 `TValue[] values` 数组用 `Item[] items` 数组代替。\n例如 `keys[i]` 变为 `items[i].Key`，`values[i]` 变为 `items[i].Value`。\n\n添加一个构造函数，调用之前编写的归并排序实现。\n\n```csharp\n/// <summary>\n/// 根据已有的键值对构造一个符号表。\n/// </summary>\n/// <param name=\"items\">已有的键值对。</param>\npublic ItemBinarySearchST(Item<TKey, TValue>[] items)\n{\n    this.items = new Item<TKey, TValue>[items.Length];\n    Array.Copy(items, this.items, items.Length);\n    this.n = items.Length;\n    MergeSort merge = new MergeSort();\n    merge.Sort(this.items);\n}\n```\n\n##### 另请参阅\n\n[Merge 库](https://alg4.ikesnowy.com/docs/api/Merge.html)\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n#### 3.1.13\n\n##### 解答\n\n`Get()` 调用次数比 `Put()` 调用次数多了三个数量级，\n`BinarySearchST` 和 `SequentialSearchST` 的平均 `Put()` 开销是一样的，\n因此选择平均 `Get()` 开销更小的 `BinarySearchST`。\n\n#### 3.1.14\n\n##### 解答\n\n根据上题给出的结论，选择 `BinarySearchST`。\n由于 `BinarySearchST` 和 `SequentialSearchST` 执行 `Put()` 的开销相同\n因此选择 `Get()` 开销更低的 `BinarySearchST`。\n\n#### 3.1.15\n\n##### 解答\n\n假设先全部 `Put()`，再进行查找操作。\n即分别进行 $ 1 $, $ 10 ^ 3 $, $ 10 ^ 6 $ 次插入\n$ N = 1 $ 时，可以直接得出比例 $ 0.1 \\% $。\n$ N = 10 ^ 3 $ 时，\n插入耗时 $ =  1 + 2 + ... + 10 ^ 3 = 500500 $，\n查询耗时 $ = 10 ^ 6 * \\lg(10 ^ 3) = 9965784 $，\n比例为 $ 4.782 \\% $。\n$ N = 10 ^ 6 $ 时\n插入耗时 $ = 1 + 2 + ... + 10 ^ 6 = 500000500000 $，\n查询耗时 $ = 10 ^ 9 * \\lg(10 ^ 6) = 19931568569 $，\n比例为 $ 96.17 \\% $。\n\n#### 3.1.16\n\n##### 解答\n\n官方实现：<https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html>\n\n先通过二分查找获得下标，然后后面的元素依次向前移动一位。\n\n```csharp\npublic void Delete(TKey key)\n{\n    if (key == null)\n        throw new ArgumentNullException(\"argument to Delete() is null\");\n    if (IsEmpty())\n        return;\n\n    int i = Rank(key);\n\n    if (i == this.n && this.keys[i].CompareTo(key) != 0)\n        return;\n\n    for (int j = i; j < this.n - 1; j++)\n    {\n        this.keys[j] = this.keys[j + 1];\n        this.values[j] = this.values[j + 1];\n    }\n\n    this.n--;\n    this.keys[this.n] = default(TKey);\n    this.values[this.n] = default(TValue);\n\n    if (this.n > 0 && this.n == this.keys.Length / 4)\n        Resize(this.n / 2);\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n#### 3.1.17\n\n##### 解答\n\n官方实现：<https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html>\n\n先通过二分查找大于等于 `key` 的键下标 `i`，\n如果 `keys[i]` 和 `key` 相等则直接返回 `keys[i]`，\n否则返回 `keys[i-1]`。\n\n```csharp\npublic TKey Floor(TKey key)\n{\n    if (key == null)\n        throw new ArgumentNullException(\"argument to Floor() is null\");\n    int i = Rank(key);\n    if (i < this.n && this.keys[i].CompareTo(key) == 0)\n        return this.keys[i];\n    if (i == 0)\n        return default(TKey);\n    else\n        return this.keys[i - 1];\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n#### 3.1.18\n\n##### 解答\n\n设 key 为目标键。\n算法初始时 lo = 0, hi = n - 1，数组已排序。\n当找到目标键时，返回的下标 mid 显然是正确的。\n（0...a[mid - 1] 都小于 a[mid]，同时 a[mid] = key）\n\n接下来证明：当目标键不存在时，lo 可以代表小于 key 的键的个数。\n由算法内容，当循环退出时，一定有 lo 和 hi 交叉，即 lo > hi。\n考虑最后一次循环，必然执行了 lo = mid + 1 或者 hi = mid - 1。\n即最后一次循环之后 lo = mid + 1 > hi 或 hi = mid - 1 < lo。\n又由于 mid = (lo + hi) / 2，代入有：\n即(lo + hi) / 2 + 1 > hi 或(lo + hi) / 2 - 1 < lo\n(lo - hi) / 2 + 1 > 0 或(hi - lo) / 2 - 1 < 0\n(hi - lo) / 2 < 1\nhi - lo < 2\n由于 hi 和 lo 都是整数，故有 hi -lo <= 1\n\n由算法的内容可以得出，最后一次循环时，\n下标小于 lo 的元素都小于 key，下标大于 hi 的元素都大于 key\n且下标小于 lo 的元素正好有 lo 个 （0...lo - 1)。\n\n当 lo = hi 时，mid = lo\n若 key > lo，则 lo = lo + 1，即 a[lo] 本身也小于 key。\n若 key < lo，lo 不变，即 a[lo] 就是大于 key 的第一个元素。\n\n当 lo = hi - 1 时，mid = lo\n若 key > lo，则 lo = lo + 1 = hi，变为上一种情况。\n若 key < lo，则 hi = lo - 1，a[lo] 是大于 key 的第一个元素。\n\n\n综上，Rank() 是正确的。\n\n#### 3.1.19\n\n##### 解答\n\n将频率和当前最大频率相同的单词都放到一个队列里即可。\n\n```csharp\nstring max = \"\";\nQueue<string> queue = new Queue<string>();\nst.Put(max, 0);\nforeach (string s in st.Keys())\n{\n    if (st.Get(s) > st.Get(max))\n    {\n        max = s;\n        queue.Clear();\n        queue.Enqueue(s);\n    }\n    else if (st.Get(s) == st.Get(max))\n    {\n        queue.Enqueue(s);\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.20\n\n##### 解答\n\n国内的书中关于命题 B 的证明有错误，新版的证明如下：\n![](https://img2018.cnblogs.com/blog/1177246/201902/1177246-20190227204527343-1004965663.png)\n虽然新版还是有个小错误，$ n-2 $ 应该改为 $ k-2 $。\n勘误见：<https://algs4.cs.princeton.edu/errata/errata-printing11.php>。\n\n先证单调性，利用数学归纳法：\n已知对于 $ N=0 $，满足 $ C(0) \\le C(1) $。\n假设对于 $ N=n $，满足 $ C(n) \\le C(n+1) $。\n根据递归式，有：\n$$\n\\begin{eqnarray*}\n& C(n) & \\le C(\\lfloor n/2 \\rfloor) + 1 \\\\\n\\\\\n& C(n+1) & \\le  \n \\begin{cases}\n C(\\lfloor n/2 \\rfloor) +1 & \\text{$ n $ 是偶数} \\\\\n C(\\lfloor n/2 \\rfloor + 1) + 1 & \\text{$ n $ 是奇数}\n \\end{cases}\\\\\n \\\\\n & C(n+2) & \\le C(\\lfloor n/2 \\rfloor + 1) + 1\n \\end{eqnarray*}\n$$\n又 $ C(n) \\le C(n+1) $ ，推出 $ C(\\lfloor n/2 \\rfloor) + 1 \\le C(\\lfloor n/2 \\rfloor + 1) + 1 $。\n故 $ C(n+1) \\le C(n+2) $，由数学归纳法，$ C(n) \\le C(n+1) $ 成立。\n\n已知当 $ N = 2^k - 1 $ 时，有 $ C(N) \\le k = \\lg(N+1) \\le \\lg N + 1$。\n接下来证明在 $ (2^k - 1,  2^{k + 1} -1)  $ 范围内上式仍然成立。\n不妨设 $ 0 < M < 2^k $ ，则有 $ 2^k - 1 < N + M < 2^{k + 1} -1   $。\n转变为证：$ C(N+M) \\le \\lg (N+M) + 1 $ 。\n由于 $ C(N+M) $ 是一个整数，则 $ \\lfloor \\lg(N+M) +1\\rfloor = k+1 $。\n即求证： $ C(N+M) \\le k+1 $。\n由单调性可得 $ C(N+M) \\le C(2^{k+1} - 1) \\le k+1 $，得证。\n\n#### 3.1.21\n\n##### 解答\n\n`BinarySearchST`\n包含一个键数组和一个值数组，以及一个 `int` 变量。\n数组长度变化范围为 N~4N ，故总大小：\n从 2 × (24 + 8N) +4 = 52 + 16N 字节 （100 %），\n到 2 × (24 + 32N) +4 = 52 + 64N 字节（25 %）之间变动。\n`SequentialSearchST`\n包含 N 个结点以及一个 `int` 变量\n(16 + 8 + 8 + 8)N + 4 = 4 + 40N 字节\n\n#### 3.1.22\n\n##### 解答\n\n对 `Get()` 做修改，得到 `MoveToFrontArrayST`。\n\n```csahrp\npublic TValue Get(TKey key)\n{\n    int i;\n    for (i = 0; i < this.n; i++)\n        if (this.keys[i].Equals(key))\n            break;\n\n    if (i == this.n)\n        return default(TValue);\n\n    TKey toFrontKey = this.keys[i];\n    TValue toFrontValue = this.values[i];\n\n    for (int j = i; j > 0; j--)\n        this.keys[j] = this.keys[j - 1];\n    for (int j = i; j > 0; j--)\n        this.values[j] = this.values[j - 1];\n\n    this.keys[0] = toFrontKey;\n    this.values[0] = toFrontValue;\n\n    return this.values[0];\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.23\n\n##### 解答\n\n这里的右移操作可以理解为 「小数点前移一位」\n即数字依次向右退一位，个位上的数字被舍弃。\n对于十进制，小数点前移一位会使 $ n $  变为 $ \\lfloor n / 10 \\rfloor $。\n同样对于二进制就会使 $ n $ 变为 $ \\lfloor n / 2 \\rfloor $。\n当需要除以 $ 2 $ 的 $ k $ 次幂的时候，可以用右移 $ k $ 位代替并减少时间开销。\n同理可以用左移 $ k $ 位来代替乘以 $ 2 $ 的 $ k $ 次幂。\n注：\n这样会降低程序可读性，\n并且某些语言（C / C++）的编译器已经可以自动执行这项优化了。\n请充分考虑你的代码受众之后再决定是否采用这种写法。\n\n二分查找的最大查找次数 = $ \\lg N + 1$ （见 3.1.20 的证明）\n一个数最多被左移的次数也正好等于 $ \\lfloor \\lg N \\rfloor + 1 $\n（任意正整数都能被表示为 $ 2 ^ k + m $ 的形式，即 $ k +1 $ 位二进制数）\n因此一次二分查找所需的最大比较次数正好是 $ N $ 的二进制表示的位数。\n\n#### 3.1.24\n\n##### 解答\n\nFrequencyCounter 的官方实现：<https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html>\n\n二分查找总是与中间值进行比较，现在改为与数组中第 x% 位置上的元素比较。\n具体而言，$ \\frac{k_x-k_{lo}}{k_{hi}-k_{lo}} $ 代表数组在均匀情况下目标值 $ k_x $ 的相对位置（一个比率，在数组第 x% 的位置上）。\n那么相对应的下标就等于 $ lo+\\frac{k_x-k_{lo}}{k_{hi}-k_{lo}} \\times (hi - lo) $。\n用这个式子代替原来的 $ mid=lo + (hi-lo)/2 $ 即可。\n\n不难看出这种方法对于分布相对均匀的数组比较有利，相对于二分查找而言迭代次数会少很多。\n但如果数组分布不够均匀，也可能表现出不如二分查找的性能。\n\n实验结果也证实了这一判断，就随机数组而言，插值查找相对于二分查找只有 1% 左右的性能提升。\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190303122510472-351020905.png)\n\n##### 代码\n\n`SearchCompare` 在书中没有出现，但可以简单的实现为调用 FrequencyCounter 并计时的方法：\n\n```csharp\npublic static long Time<TKey>(IST<TKey, int> st, TKey[] keys)\n{\n    Stopwatch sw = new Stopwatch();\n    sw.Start();\n    FrequencyCounter.MostFrequentlyKey(st, keys);\n    sw.Stop();\n    return sw.ElapsedMilliseconds;\n}\n```\n\n由于这里需要使用数字而非字符串作为键值，需要对官方给出的 `FrequencyCounter` 做一些修改：\n\n```csharp\npublic static TKey MostFrequentlyKey<TKey> (IST<TKey, int> st, TKey[] keys)\n{\n    foreach (TKey s in keys)\n    {\n        if (st.Contains(s))\n            st.Put(s, st.Get(s) + 1);\n        else\n            st.Put(s, 1);\n    }\n\n    TKey max = keys[0];\n    foreach (TKey s in st.Keys())\n        if (st.Get(s) > st.Get(max))\n            max = s;\n\n    return max;\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.25\n\n##### 解答\n\n英文原文指的是 most recently accessed key，因此指的是最近访问的键。\n\n实现比较简单，先在类中定义一个新的成员 `cache` 作为缓存，\n然后修改 `Get` 方法，在实际查找之前先检查缓存，如果缓存未命中则在查找之后更新它。\n要注意的是缓存指向内容的有效性，在数组中指的是下标是否有效，在链表中指的是结点是否为空。\n\n利用《双城记》测试的结果：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190303122544675-1083750040.png)\n\n##### 代码\n\n### BinarySearchST\n\n`cache` 是一个 `int` 类型的变量，代表下标。\n在二分查找前先检查缓存，要注意`cache`超出数组大小的情况。\n如果缓存未命中，则进行二分查找，并在返回结果前更新缓存。\n\n```csharp\npublic TValue Get(TKey key)\n{\n    if (key == null)\n        throw new ArgumentNullException(\"argument to Get() is null\");\n    if (IsEmpty())\n        return default(TValue);\n    if (this.cache < this.n && this.keys[this.cache].Equals(key)) // 缓存检查\n        return this.values[this.cache];\n    int rank = Rank(key);\n    if (rank < this.n && this.keys[rank].Equals(key))\n    {\n        this.cache = rank;                                        // 更新缓存\n        return this.values[rank];\n    }\n\n    return default(TValue);\n}\n```\n\n### SequentialSearchST\n\n`cache` 是一个结点类型的变量，代表一个键值对。\n类似的，在顺序查找前先检查缓存，如果缓存未命中则更新缓存。\n要注意的是如果缓存的结点被删除，需要将缓存置为 `null`。\n\n`Get()` 方法\n\n```csharp\npublic TValue Get(TKey key)\n{\n    if (key == null)\n        throw new ArgumentNullException(\"key can't be null\");\n\n    if (this.cache != null && this.cache.Key.Equals(key)) // 检查缓存\n        return this.cache.Value;\n    for (Node pointer = this.first; pointer != null; pointer = pointer.Next)\n    {\n        if (pointer.Key.Equals(key))\n        {\n            this.cache = pointer;                         // 更新缓存\n            return pointer.Value;\n        }\n    }\n    return default(TValue);\n}\n```\n\n`Delete()` 方法\n\n```csharp\npublic void Delete(TKey key)\n{\n    if (key == null)\n        throw new ArgumentNullException(\"key can't be null\");\n    Node before = null, target = this.first;\n    while (target != null && !target.Key.Equals(key))\n    {\n        before = target;\n        target = target.Next;\n    }\n    if (target == this.cache)           // 删除缓存\n        this.cache = null;\n    if (target != null)\n        Delete(before, target);\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.26\n\n##### 解答\n\n字典文件：<https://introcs.cs.princeton.edu/java/data/web2.txt>\n《双城记》：<https://introcs.cs.princeton.edu/java/data/tale.txt>\n浏览器可能会直接打开 txt，此时右键链接-目标另存为即可下载。\n\n`FrequencyCounter` 的官方实现：<https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html>\n\n我们利用 `BinarySearchST` 会自动对键排序的性质来实现字典序排序。\n首先将字典存到一个符号表中，按照 “单词-序号” 的形式保存。\n然后读入文件，如果读入的单词存在于字典中，\n则将其以 “序号-单词” 的形式存到 `BinarySearchST` 中去。\n读入完毕后，遍历 `BinarySearchST` 即可获得字典序的单词列表。\n\n对于按频率排序，我们基于已有的实现修改。\n在每次取得最大值之后，输出并删除最大值，如此循环即可获得频率排序的单词序列。\n也可以将单词-频率序列全部读出来存放到数组之中，然后用第二章的排序算法排序。\n\n测试结果，取 minLength = 13，只截取了部分。\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190303122605154-59713946.png)\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190303122615371-1288643672.png)\n\n##### 代码\n\n```csharp\npublic static void LookUpDictionary(string filename, string dictionaryFile, int minLength)\n{\n    // 初始化字典\n    StreamReader sr = new StreamReader(File.OpenRead(dictionaryFile));\n    string[] words = sr.ReadToEnd().Split(new char[] { ' ', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries);\n    BinarySearchST<string, int> dictionary = new BinarySearchST<string, int>();\n    for (int i = 0; i < words.Length; i++)\n    {\n        if (words[i].Length > minLength)\n            dictionary.Put(words[i], i);\n    }\n    sr.Close();\n\n    // 读入单词\n    StreamReader srFile = new StreamReader(File.OpenRead(filename));\n    string[] inputs = srFile.ReadToEnd().Split(new char[] { ' ', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries);\n    srFile.Close();\n\n    BinarySearchST<int, string> stDictionary = new BinarySearchST<int, string>();\n    BinarySearchST<string, int> stFrequency = new BinarySearchST<string, int>();\n    foreach (string s in inputs)\n    {\n        if (stFrequency.Contains(s))\n            stFrequency.Put(s, stFrequency.Get(s) + 1);\n        else if (dictionary.Contains(s))\n        {\n            stFrequency.Put(s, 1);\n            stDictionary.Put(dictionary.Get(s), s);\n        }\n    }\n\n    // 输出字典序\n    Console.WriteLine(\"Alphabet\");\n    foreach (int i in stDictionary.Keys())\n    {\n        string s = stDictionary.Get(i);\n        Console.WriteLine(s + \"\\t\" + stFrequency.Get(s));\n    }\n\n    // 频率序\n    Console.WriteLine(\"Frequency\");\n    int n = stFrequency.Size();\n    for (int i = 0; i < n; i++)\n    {\n        string max = \"\";\n        stFrequency.Put(max, 0);\n        foreach (string s in stFrequency.Keys())\n            if (stFrequency.Get(s) > stFrequency.Get(max))\n                max = s;\n        Console.WriteLine(max + \"\\t\" + stFrequency.Get(max));\n        stFrequency.Delete(max);\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.27\n\n##### 解答\n\n事实上就是说，先构造一个包含 N 个不重复键的符号表，然后进行 S 次查找。\n给出 S 的增长数量级，使得构造符号表的成本和查找的成本相同。\n\n这里假设一次数组交换和一次比较的成本是相同的。\n先考虑构造符号表的成本，一次 `Put()` 需要调用一次 `Rank()` 和一次插入操作。\n2.1 节插入排序的命题 B 给出了每次插入平均需要移动一半的数组元素的结论。\n于是构造符号表所需的成本约为：$n\\lg n + \\frac{1}{2}\\sum_{k=1}^{n} k=n\\lg n + \\frac{n(n-1)}{4} $ 。\n这里查找的成本是这么计算的：$ \\lg0+\\lg1+\\cdots+\\lg n < n\\lg n $\n查找所需的成本比较简单，一次二分查找的比较次数约为 $ \\lg n $，总成本就是 $ S\\lg n $ 。\n令两边相等，解方程即可得到 $ S=n+\\frac{n(n-1)}{4\\lg n} $ 。\n\n如果用大 O 记法，也可以记为 $ O(n^2 / \\lg n) $，如果要选择一个比较常用的上界则可以选择 $ O(n^2) $。\n\n实验结果，两边的成本是很接近的：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190304203324086-1121855400.png)\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n#### 3.1.28\n\n##### 解答\n\n将重新分配数组空间的代码提前，然后添加判断语句即可。\n`BinarySearchSTOrderedInsertion`：\n\n```csharp\n/* 省略 */\n\nif (this.n == this.keys.Length)\n    Resize(this.n * 2);\n\n// 如果插入的键比所有键都大则直接插入末尾。\nif (this.n == 0 || this.keys[this.n - 1].CompareTo(key) < 0)\n{\n    this.keys[this.n] = key;\n    this.values[this.n] = value;\n    this.n++;\n    return;\n}\n\nint i = Rank(key);\n\n/* 省略 */\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.29\n\n##### 解答\n\n官方实现：<https://algs4.cs.princeton.edu/31elementary/TestBinarySearchST.java.html>\n\n官方实现中有几处错误，需要做一些修改。\n\n```csharp\n/* 省略 */\n\nConsole.WriteLine(\"Testing Select()\");\nConsole.WriteLine(\"-----------------------------------\");\nfor (int i = 0; i < st.Size(); i++) // 循环条件不能有 '='\n    Console.WriteLine(i + \" \" + st.Select(i));\nConsole.WriteLine();\n\n/* 省略 */\n\nwhile (!st.IsEmpty())\n    st.Delete(st.Select(st.Size() / 2));\nConsole.WriteLine(\"After deleting the remaining keys\");\nConsole.WriteLine(\"-----------------------------------\");\n// 异常处理\ntry\n{\n    foreach (string s in st.Keys())\n        Console.WriteLine(s + \" \" + st.Get(s));\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"Exception: \" + ex.Message);\n}\nConsole.WriteLine();\n\n/* 省略 */\n```\n\n结果如下：\n\n```\nsize = 10\nmin = A\nmax = X\n\nTesting Keys()\n-----------------------------------\nA 8\nC 4\nE 12\nH 5\nL 11\nM 9\nP 10\nR 3\nS 0\nX 7\n\nTesting Select()\n-----------------------------------\n0 A\n1 C\n2 E\n3 H\n4 L\n5 M\n6 P\n7 R\n8 S\n9 X\n\nkey Rank Floor Ceil\n-----------------------------------\nA 0 A A\nB 1 A C\nC 1 C C\nD 2 C E\nE 2 E E\nF 3 E H\nG 3 E H\nH 3 H H\nI 4 H L\nJ 4 H L\nK 4 H L\nL 4 L L\nM 5 M M\nN 6 M P\nO 6 M P\nP 6 P P\nQ 7 P R\nR 7 R R\nS 8 S S\nT 9 S X\nU 9 S X\nV 9 S X\nW 9 S X\nX 9 X X\nY 10 X\nZ 10 X\n\nAfter deleting the smallest 3 keys\n-----------------------------------\nH 5\nL 11\nM 9\nP 10\nR 3\nS 0\nX 7\n\nAfter deleting the remaining keys\n-----------------------------------\nException: called Min() with empty table\n\nAfter adding back N keys\n-----------------------------------\nA 8\nC 4\nE 12\nH 5\nL 11\nM 9\nP 10\nR 3\nS 0\nX 7\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.30\n\n##### 解答\n\n官方实现：<https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html>。\n\n首先在 `BinarySearchST ` 中添加如下方法。\n\n```csharp\n/// <summary> 检查符号表结构是否有效。 </summary>\nprivate bool Check() => IsSorted() && RankCheck();\n\n/// <summary> 检查 <see cref=\"keys\"/> 数组是否有序。 </summary>\nprivate bool IsSorted()\n{\n    for (int i = 1; i < Size(); i++)\n        if (this.keys[i].CompareTo(this.keys[i - 1]) < 0)\n            return false;\n    return true;\n}\n\n/// <summary> 检查 Rank(Select(i)) = i 是否成立。 </summary>\nprivate bool RankCheck()\n{\n    for (int i = 0; i < Size(); i++)\n        if (i != Rank(Select(i)))\n            return false;\n    for (int i = 0; i < Size(); i++)\n        if (keys[i].CompareTo(Select(Rank(this.keys[i]))) != 0)\n            return false;\n    return true;\n}\n```\n\n然后在 `Put()` 和 `Delete()` 方法的末尾添加：`Debug.Assert(Check());` 即可。\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n#### 3.1.31\n\n##### 解答\n\n性能测试方法构造如下：\n先编写一个随机字符串方法，生成一个长度大于 50 的字符串（作为未命中访问）。\n然后随机生成符合要求的字符串数组，将它们全部放入符号表中。\n然后遍历 10 次生成的字符串数组，对于数组中的每个元素都进行一次命中查询。\n同时在每次命中查询的同时都进行一次未命中查询即可。\n\n测试结果：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324214534925-1396993505.png)\n\n##### 代码\n\n按照要求编写代码，在 `SearchCompare` 类里添加一个 `Random random` 成员，并添加如下方法：\n随机字符串发生器：\n\n```csharp\npublic static string GetRandomString(int minLength, int maxLength)\n{\n    int length = random.Next(minLength, maxLength);\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < length; i++)\n    {\n        double choice = random.NextDouble();\n        if (choice < 0.333)\n            sb.Append((char)random.Next('A', 'Z'));\n        else if (choice < 0.666)\n            sb.Append((char)random.Next('a', 'z'));\n        else\n            sb.Append((char)random.Next('0', '9'));\n    }\n    return sb.ToString();\n}\n```\n\n生成随机字符串数组：\n\n```csharp\npublic static string[] GetRandomArrayString(int n, int minLength, int maxLength)\n{\n    string[] result = new string[n];\n    for (int i = 0; i < n; i++)\n    {\n        result[i] = GetRandomString(minLength, maxLength);\n    }\n    return result;\n}\n```\n\n测试方法：\n\n```csharp\npublic static long Performance(IST<string, int> st, int n, int averageHit)\n{\n    string[] keys = GetRandomArrayString(n, 2, 50);\n    string keyNotExist = GetRandomString(51, 52);\n    Stopwatch sw = Stopwatch.StartNew();\n    // 构建\n    for (int i = 0; i < n; i++)\n        st.Put(keys[i], i);\n    // 查询\n    for (int i = 0; i < averageHit; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            st.Get(keys[j]);\n            st.Get(keyNotExist);\n        }\n    }\n    sw.Stop();\n    return sw.ElapsedMilliseconds;\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n#### 3.1.32\n\n##### 解答\n\n编码实现即可，实验结果如下：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324214903675-1599756683.png)\n\n对于保持键有序的 `BinarySearchST` 来说，逆序输入是最坏情况，顺序输入则是最好情况。\n而对于键无序的 `SequentialSearchST` 来说，输入顺序对于性能的影响不大。\n只有一种键的时候，每次 `Put` 都只需要比较一次，值一直在被替换。\n只有两种值对性能的影响不大，性能主要由输入的键决定。\n\n##### 代码\n\n测试方法，`IST` 代表一个符号表。\n\n```csharp\nstatic void Test(IST<string, int>[] sts, int n)\n{\n    Stopwatch sw = new Stopwatch();\n    string[] data = SearchCompare.GetRandomArrayString(n, 3, 10);\n    string item1 = \"item1\";\n    Array.Sort(data);\n\n    // 有序的数组\n    Console.Write(\"Sorted Array: \");\n    sw.Start();\n    for (int i = 0; i < n; i++)\n    {\n        sts[0].Put(data[i], i);\n    }\n    sw.Stop();\n    Console.WriteLine(sw.ElapsedMilliseconds);\n\n    // 逆序的数组\n    Console.Write(\"Sorted Array Reversed: \");\n    sw.Restart();\n    for (int i = n - 1; i >= 0; i--)\n    {\n        sts[1].Put(data[i], i);\n    }\n    sw.Stop();\n    Console.WriteLine(sw.ElapsedMilliseconds);\n\n    // 只有一种键\n    Console.Write(\"One Distinct Key: \");\n    sw.Restart();\n    for (int i = 0; i < n; i++)\n    {\n        sts[2].Put(item1, i);\n    }\n    sw.Stop();\n    Console.WriteLine(sw.ElapsedMilliseconds);\n\n    // 只有两种值\n    Console.Write(\"Two Distinct Values: \");\n    sw.Restart();\n    for (int i = 0; i < n; i++)\n    {\n        sts[3].Put(data[i], i % 2);\n    }\n    sw.Stop();\n    Console.WriteLine(sw.ElapsedMilliseconds);\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n#### 3.1.33\n\n##### 解答\n\n概率分布的实现方式：\n假设存有键的数组为 `keys`，对 `keys` 排序。\n然后再建立一个长度为 10N 的数组 `querys`，\n前 1/2 置为 `keys[0]`，1/2 到 3/4 置为 `keys[1]`，以此类推，直到数组填满。\n然后遍历 `query` 数组，对符号表进行 `Get()` 操作。\n\n实验结果如下：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215036454-1769907999.png)\n\n##### 代码\n\n```csharp\nstatic void Main(string[] args)\n{\n    int n = 1000;\n    int multiplyBy10 = 3;\n    for (int i = 0; i < multiplyBy10; i++)\n    {\n        Console.WriteLine(\"n=\" + n);\n        // 构造表\n        BinarySearchST<string, int> bst = new BinarySearchST<string, int>(n);\n        MoveToFrontArrayST<string, int> mst = new MoveToFrontArrayST<string, int>(n);\n        string[] keys = SearchCompare.GetRandomArrayString(n, 3, 20);\n        for (int j = 0; j < n; j++)\n        {\n            bst.Put(keys[j], j);\n            mst.Put(keys[j], j);\n        }\n        // 构造查询\n        Array.Sort(keys);\n        string[] querys = new string[10 * n];\n        int queryIndex = 0, keyIndex = 0;\n        while (queryIndex < querys.Length)\n        {\n            int searchTimes = (int)Math.Ceiling((Math.Pow(0.5, keyIndex + 1) * querys.Length));\n                    \n            for (int j = 0; j < searchTimes && queryIndex < querys.Length; j++)\n            {\n                querys[queryIndex++] = keys[keyIndex];\n            }\n            keyIndex++;\n        }\n        Shuffle(querys);\n\n        Stopwatch sw = new Stopwatch();\n        // 测试 MoveToFrontArrayST\n        sw.Start();\n        for (int j = 0; j < querys.Length; j++)\n        {\n            mst.Get(querys[j]);\n        }\n        sw.Stop();\n        Console.WriteLine(\"MoveToFrontArrayST: \" + sw.ElapsedMilliseconds);\n\n        // 测试 BinarySearchST\n        sw.Restart();\n        for (int j = 0; j < querys.Length; j++)\n        {\n            bst.Get(querys[j]);\n        }\n        sw.Stop();\n        Console.WriteLine(\"BinarySearchST: \" + sw.ElapsedMilliseconds);\n\n        n *= 10;\n    }\n}\n\nstatic void Shuffle<T>(T[] data)\n{\n    for (int i = 0; i < data.Length; i++)\n    {\n        int r = i + random.Next(data.Length - i);\n        T temp = data[r];\n        data[r] = data[i];\n        data[i] = temp;\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.34\n\n##### 解答\n\n在上一题的基础上进行修改即可，链接：{% post_link 3.1.33 %}。\n\n调和级数 $ H_n = 1+\\frac{1}{2}+\\frac{1}{3} + \\cdots+\\frac{1}{n} $ 。\n查询数组变为前 1/2 为 `key[0]`，随后的 1/3 为 `key[1]`，以此类推。\n和上一题中的序列进行比较即可，注意删除最后的打乱步骤。\n\n实验结果如下：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215243014-218453716.png)\n\n##### 代码\n\n首先建立一个数组计算调和级数，就像这样：\n\n```csharp\n// 调和级数\ndouble[] harmonicNumber = new double[1000 * (int)Math.Pow(10, 4)];\nharmonicNumber[0] = 1;\nfor (int i = 1; i < harmonicNumber.Length; i++)\n{\n    harmonicNumber[i] = harmonicNumber[i - 1] + 1 / (i + 1);\n}\n```\n\n然后修改构造查询的代码：\n\n```csharp\n// 构造查询\nArray.Sort(keys);\nstring[] queryZipf = new string[10 * n];\nint queryIndex = 0, keyIndex = 0;\nwhile (queryIndex < queryZipf.Length)\n{\n    int searchTimes = (int)Math.Ceiling(queryZipf.Length / (harmonicNumber[keyIndex + 1] * (i + 1)));\n\n    for (int j = 0; j < searchTimes && queryIndex < queryZipf.Length; j++)\n    {\n        queryZipf[queryIndex++] = keys[keyIndex];\n    }\n    keyIndex++;\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.35\n\n##### 解答\n\n实验结果：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215412407-1474793289.png)\n\n由于包含重复单词，因此结果会比 4 略低一些。\n需要对 `FrequencyCounter` 做一些修改，令其只取前 n 个单词。\n\n##### 代码\n\n```csharp\nstatic void Main(string[] args)\n{\n    int n = 8000;\n    int multiplyBy2 = 5;\n    int repeatTimes = 5;\n    double lastTime = -1;\n    Console.WriteLine(\"n\\ttime\\tratio\");\n    for (int i = 0; i < multiplyBy2; i++)\n    {\n        Console.Write(n + \"\\t\");\n        long timeSum = 0;\n        for (int j = 0; j < repeatTimes; j++)\n        {\n            SequentialSearchST<string, int> st = new SequentialSearchST<string, int>();\n            Stopwatch sw = Stopwatch.StartNew();\n            FrequencyCounter.MostFrequentlyWord(\"tale.txt\", n, 0, st);\n            sw.Stop();\n            timeSum += sw.ElapsedMilliseconds;\n        }\n        timeSum /= repeatTimes;\n        Console.Write(timeSum + \"\\t\");\n        if (lastTime < 0)\n            Console.WriteLine(\"--\");\n        else\n            Console.WriteLine(timeSum / lastTime);\n        lastTime = timeSum;\n        n *= 2;\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n#### 3.1.36\n\n##### 解答\n\n实验结果如下，增长级为 O(N) ，但速度很快。\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215528294-832816508.png)\n\n其实只要列出《双城记》不同长度的单词数目，原因就一目了然了。\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215540375-156676566.png)\n大部分单词都集中在中间长度，因此大部分访问也集中在数组中部。\n二分查找在访问数组中部的元素时速度很快，因此结果好于预期。\n\n##### 代码\n\n```csharp\nstatic void Main(string[] args)\n{\n    int n = 8000;\n    int multiplyBy2 = 5;\n    int repeatTimes = 5;\n    double lastTime = -1;\n    Console.WriteLine(\"n\\ttime\\tratio\");\n    for (int i = 0; i < multiplyBy2; i++)\n    {\n        Console.Write(n + \"\\t\");\n        long timeSum = 0;\n        for (int j = 0; j < repeatTimes; j++)\n        {\n            BinarySearchST<string, int> st = new BinarySearchST<string, int>();\n            Stopwatch sw = Stopwatch.StartNew();\n            FrequencyCounter.MostFrequentlyWord(\"tale.txt\", n, 0, st);\n            sw.Stop();\n            timeSum += sw.ElapsedMilliseconds;\n        }\n        timeSum /= repeatTimes;\n        Console.Write(timeSum + \"\\t\");\n        if (lastTime < 0)\n            Console.WriteLine(\"--\");\n        else\n            Console.WriteLine(timeSum / lastTime);\n        lastTime = timeSum;\n        n *= 2;\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.37\n\n##### 解答\n\n实验结果如下：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215652239-143750005.png)\n\nM=10 的时候随机的数字集中在 1024 到 2048 之间，重复值较多，因此 `Put` 耗时较少。\n随着重复值的减少 `Put` 的耗时会大幅度提高，和实验结果显示的一样。\nM=20 的时候数字在 1048576~2097152 之间随机，基本上没有重复值了。\nM=30 的时候和 M=20 的情况类似，都是重复值几乎没有的情况。\n\n随机数可以通过如下的方式产生：\n\n```csharp\nresult[i] = min + (long)(random.NextDouble() * (max - min));\n```\n\n##### 代码\n\n这里构造了 `BinarySearchSTAnalysis` 类，在类中声明了两个 Stopwatch 对象，\n一个在 `Put` 方法的开始和结束部分进行计时，\n另一个在 `Get` 方法的开始和结束部分进行计时。\n\n```csharp\nstatic void Main(string[] args)\n{\n    int n = 1000000;\n    int m = 10;\n    int addBy10 = 3;\n\n    for (int i = 0; i < addBy10; i++)\n    {\n        BinarySearchSTAnalysis<long, int> bst = new BinarySearchSTAnalysis<long, int>(n);\n        long[] data = SearchCompare.GetRandomArrayLong(n, (long)Math.Pow(2, m), (long)Math.Pow(2, m + 1));\n        FrequencyCounter.MostFrequentlyKey(bst, data);\n        Console.WriteLine(\"m=\" + m + \"\\t\" + bst.GetTimer.ElapsedMilliseconds + \"\\t\" + bst.PutTimer.ElapsedMilliseconds + \"\\t\" + bst.PutTimer.ElapsedMilliseconds / (double)bst.GetTimer.ElapsedMilliseconds);\n        m += 10;\n    }\n\n    BinarySearchSTAnalysis<string, int> st = new BinarySearchSTAnalysis<string, int>();\n    FrequencyCounter.MostFrequentlyWord(\"tale.txt\", 0, st);\n    Console.WriteLine(\"tales\\t\" + st.GetTimer.ElapsedMilliseconds + \"\\t\" + st.PutTimer.ElapsedMilliseconds + \"\\t\" + st.PutTimer.ElapsedMilliseconds / (double)st.GetTimer.ElapsedMilliseconds);\n    Console.ReadLine();\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.38\n\n##### 解答\n\n实验结果如下：\nBinarySearchST\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215831063-1414290190.png)\n\nSequentialSearchST\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215841241-1572438759.png)\n\n对于 `BinarySearchST` ，每次比较之后以及移动元素时令 `Cost` 增加。\n对于 `SequentialSearchST`，统计每次的查找次数即可。\n然后绘制成散点图即可。\n\n##### 代码\n\n有关绘图的函数，传入的参数为第 `i` 次 `Put()` 的开销。\n\n```csharp\npublic void Draw(int[] data)\n{\n    Graphics panel = this.CreateGraphics();\n    float unitX = (float)this.ClientRectangle.Width / data.Length;\n    float unitY = (float)this.ClientRectangle.Height / data.Max();\n\n    int accumulation = 0;\n    for (int i = 0; i < data.Length; i++)\n    {\n        // Gray\n        panel.FillEllipse(Brushes.Gray, (i + 1) * unitX, this.ClientRectangle.Bottom - data[i] * unitY, 2, 2);\n        // Red\n        panel.FillEllipse(Brushes.Red, (i + 1) * unitX, this.ClientRectangle.Bottom - accumulation / (i + 1) * unitY, 2, 2);\n        accumulation += data[i];\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.39\n\n##### 解答\n\n实验结果如下：\n`BinarySearchST`\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215947598-1655254268.png)\n\n`SequentialSearchST`\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324215955151-1354629773.png)\n\n图像分为两段，分别代表不断向符号表中加入单词和寻找频率最大的单词两个部分。\n第一段两个图像的形状类似（注意它们的 y 轴比例不同）。\n第二段中 `BinarySearchST` 的表现要比 `SequentialSearchST` 稳定的多。\n\n##### 代码\n\n绘图部分代码：\n\n```csharp\npublic void Draw(int[] x, long[] y)\n{\n    Graphics panel = this.CreateGraphics();\n\n    float unitX = (float)this.ClientRectangle.Width / x.Max();\n    float unitY = (float)this.ClientRectangle.Height / y.Max();\n\n    for (int i = 0; i < x.Length; i++)\n    {\n        panel.FillEllipse(\n            Brushes.Black,\n            x[i] * unitX,\n            this.ClientRectangle.Height - y[i] * unitY,\n            2, 2);\n    }\n}\n```\n\n##### 另请参阅\n\n[SymbolTable 库](https://alg4.ikesnowy.com/docs/api/SymbolTable.html)\n\n\n#### 3.1.40\n\n##### 解答\n\n顺序查找平均需要进行 $ N/2 $ 次比较，二分查找则是 $ \\lg N $ 次。\n列出方程可以解出 N 的大小\n$$\n\\begin {eqnarray*}\n1000 \\log_2 N &=& N / 2 \\\\\n\\log_2 N &=& N / 2000\\\\\n\\frac{\\ln N}{\\ln 2} &=& N/2000 \\\\\nN &=& e^{\\frac{\\ln 2}{2000}N}\\\\\n1 &=& Ne^{-\\frac{\\ln 2}{2000}N}\\\\\nN_1 = e^{-W(-\\frac{\\ln 2}{2000})}=1 &\\ & N_2= e^{-W_{-1}(-\\frac{\\ln 2}{2000})}=29718\\\\ \\\\\n\\end {eqnarray*}\n$$\n这个方程是一个超越方程，最后的结果中出现了朗伯 W 函数。\n同理可以求得 10000 倍的 N=369939。\n\n实验结果如下：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324220053371-1056644227.png)\n\n由于存在缓存优化，每次比较的耗时并不相同。\n因此实际耗时并未达到预期，但比较次数是符合预期的。\n\n##### 另请参阅\n\n[朗伯 W 函数-维基百科](https://zh.wikipedia.org/zh-hans/%E6%9C%97%E4%BC%AFW%E5%87%BD%E6%95%B0)\n\n\n#### 3.1.41\n\n##### 解答\n\n英文版描述为 1, 2, and 10 times faster。\n即一样快，快一倍和快十倍（[一个例子](https://math.stackexchange.com/questions/12768/what-does-1-13-times-faster-mean)）。\n\n和上题类似，也是解超越方程。\n插值查找的平均查找次数为 $ \\lg(\\lg(N)) $。\n可以解得 N = 1, 4, 58。\n\n实验结果如下：\n![](https://img2018.cnblogs.com/blog/1177246/201903/1177246-20190324220228670-1813070824.png)\n\n由于 N 太小，可以看到插值查找的运行时间几乎没有变化。",
  "type": "md"
}
